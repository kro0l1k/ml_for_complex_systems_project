import time
import numpy as np
import torch
import math
from scipy.stats import multivariate_normal as normal
from collections import namedtuple
import matplotlib.pyplot as plt
from pres_config_file import Config

LAMBDA = 0.1 # was 0.05

# Set default tensor type to float
torch.set_default_dtype(torch.float32)

# Check for available devices 
device = torch.device("cuda" if torch.cuda.is_available() else "mps" if torch.backends.mps.is_available() else "cpu")
print(f"Using device: {device}")

class Solver(object):
    def __init__(self, x_0_value=1.0):
        self.config = Config()
        
        self.valid_size = self.config.valid_size
        self.batch_size = self.config.batch_size
        self.num_iterations = self.config.num_iterations
        self.logging_frequency = self.config.logging_frequency
        self.lr_values = self.config.lr_values
        self.lr_boundaries = self.config.lr_boundaries
        self.x_0_value = x_0_value
        
        
    def generate_trajectoy(self, sample_size, x_0_value = 1.0):
        """Generate the trajectory of the model. start from the initial value of X0 and apply the control generated by the FFNetU"""
        
        # Generate sample data for simulation
        sample_data = self.config.sample(sample_size)
        delta_W_TBW, _, jump_mask_TBLC, jump_sizes_BLCX = sample_data
        
        X_BX = self.config.X_init.repeat(sample_size, 1) * x_0_value  # Shape: (sample_size, dim_X)
        trajectory = []
        trajectory.append(X_BX.detach().cpu().numpy())  # Store initial state

        for t in range(self.config.time_step_count):
            current_time = t * self.config.delta_t
            # u_BU = self.model.u_net((current_time, X_BX))  # Access u_net through self.model
            # print("needed u_BU: ", u_BU.shape)
            u_BU = torch.ones((sample_size, self.config.dim_u), dtype=torch.float32, device=device)
            # Update X using drift
            X_BX = X_BX + self.config.drift(current_time, X_BX, u_BU) * self.config.delta_t

            # Add diffusion term
            X_BX = X_BX + torch.einsum('bxw,bw->bx',
                                       self.config.diffusion(current_time, X_BX, u_BU),
                                       delta_W_TBW[t, :, :])

            # Add jump terms
            for l in range(self.config.dim_L):
                X_BX = X_BX + u_BU * torch.einsum('bc,bcx->bx', 
                                                 jump_mask_TBLC[t, :, l, :], 
                                                 jump_sizes_BLCX[:, l, :, :])
                # Compensation term
                X_BX = X_BX - self.config.jump_intensity[l] * (np.exp(self.config.log_normal_mu[l] + 0.5 * self.config.log_normal_sigma[l] ** 2) - 1) * u_BU * self.config.delta_t

            trajectory.append(X_BX.detach().cpu().numpy())

        return np.array(trajectory)
    
    def plot_trajectory(self, trajectory):
        """Plot the trajectory of the model"""
        # Use trajectory.shape[0] to ensure t has the right number of points
        t = np.linspace(0, self.config.terminal_time, trajectory.shape[0])
        
        for i in range(self.config.dim_X):
            # Plot each sample separately
            for sample_idx in range(trajectory.shape[1]):
                plt.plot(t, trajectory[:, sample_idx, i])
        
        plt.title('Trajectory of the model')
        plt.xlabel('t')
        plt.ylabel('X(t)')
        plt.grid()
        # plt.show()
        

def main():
    config = Config()
    print("starting the code")
    print("target mean A: ", config.TARGET_MEAN_A)
    # Set the random seed for reproducibility
    torch.manual_seed(42)
    # config.sample_stock_price(sample_size=10)
    x_0_values = np.array([70, 80, 90, 100, 110, 120])
    V_for_different_x0 = []
    std_for_different_x0 = []
    print("testing for different x_0 values")
    for x_0 in x_0_values:
        print('\n\n\n x_0: ', x_0)
        # Initialize the solver with the initial value of X0
        solver = Solver(x_0_value=x_0)
        # solver.train()
        # generate the trajectory
        trajectory = solver.generate_trajectoy(256, x_0_value=x_0)
        # plot the trajectory
        
        solver.plot_trajectory(trajectory)
        
        # print('Trajectory shape after the plot: ', trajectory.shape)
        # compute the cost functional for each of the trajectories. get the mean and std
        cost_functional = np.mean(np.sum((trajectory - config.TARGET_MEAN_A) ** 2, axis=2), axis=0) 
        print("cost finctional shape: ", cost_functional.shape)
        print('Cost functional: ', cost_functional)
        print('Mean: ', np.mean(cost_functional))
        print('Std: ', np.std(cost_functional))
        V_for_different_x0.append(np.mean(cost_functional))
        std_for_different_x0.append(np.std(cost_functional))
    
    ### plot the cost functional for different x_0 values. add a transparent area for +-1 std
    plt.figure()
    plt.plot(x_0_values, V_for_different_x0, label='Mean Cost Functional')
    lower_bound = np.array(V_for_different_x0) - np.array(std_for_different_x0)
    lower_bound[lower_bound < 0] = 0  # Ensure lower bound is non-negative
    
    plt.fill_between(x_0_values, 
                     lower_bound, 
                     np.array(V_for_different_x0) + np.array(std_for_different_x0), 
                     alpha=0.2, label='1 Std Dev')
    plt.title('Cost Functional for Different Initial Values of X0, and const control = 1')
    plt.xlabel('Initial Value of X0')
    plt.ylabel('Cost Functional')
    plt.legend()
    plt.grid()
    plt.show()
    
    print(" high lambda, B = 256")
    print("Cost Functional for different x_0 values:")
    print("Mean: \n", V_for_different_x0)
    print("Std: \n", std_for_different_x0)
    # save the plot
    plt.savefig('cost_functional_2.png')
    plt.close()
    

if __name__ == '__main__':
    main()